// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {IERC721} from "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol";
import {Currency} from "lib/v4-core/src/types/Currency.sol";
import {Actions} from "lib/v4-periphery/src/libraries/Actions.sol";
import {IPositionManager} from "lib/v4-periphery/src/interfaces/IPositionManager.sol";

/// @title LiquidityLockUniv4WithFees
/// @notice A contract for locking Uniswap V4 NFTs representing liquidity positions, while at the same time allowing to claim fees generated by the position.
contract LiquidityLockUniv4WithFees {
    /// @notice Uniswap V4 NFT positions contract
    IERC721 public immutable UNISWAPV4_NFT;

    /// @notice Uniswap V4 position manager contract
    IPositionManager public immutable UNISWAPV4_POSITION_MANAGER;

    /// @notice Mapping of position IDs to their lock owners
    mapping(uint256 positionId => address owner) public lockOwners;

    ///////////////////// Errors /////////////////////

    error PositionIsAlreadyLocked();
    error NotPositionOwner();
    error CannotWithdrawPositionNft();

    ///////////////////// Events /////////////////////

    /// @notice Emitted when a position is locked
    event PositionLocked(address indexed sender, address indexed positionReceiver, uint256 indexed positionId);
    /// @notice Emitted when fees are claimed from a locked position
    event PositionFeesClaimed(
        address indexed owner, uint256 indexed positionId, address token0, address token1, address recipient
    );

    //////////////////////////////////////////////////

    /// @notice Initializes the liquidity lock contract
    /// @param _uniswapV4Nft Address of the Uniswap V4 NFT positions contract
    /// @param _uniswapPositionManager Address of the Uniswap V4 position manager
    constructor(address _uniswapV4Nft, address _uniswapPositionManager) {
        UNISWAPV4_NFT = IERC721(_uniswapV4Nft);
        UNISWAPV4_POSITION_MANAGER = IPositionManager(_uniswapPositionManager);
    }

    //////////////////  EXTERNALS ////////////////////

    /// @notice Locks a Uniswap V4 position NFT in this contract
    /// @param positionId The ID of the position to lock
    /// @param positionReceiver The address that will be recorded as the owner of the locked position
    function lockUniV4Position(uint256 positionId, address positionReceiver) external {
        if (lockOwners[positionId] != address(0)) revert PositionIsAlreadyLocked();

        lockOwners[positionId] = positionReceiver;

        emit PositionLocked(msg.sender, positionReceiver, positionId);

        IERC721(UNISWAPV4_NFT).transferFrom(msg.sender, address(this), positionId);
    }

    /// @notice Claims fees from a locked Uniswap V4 position
    /// @param positionId The ID of the position to claim fees from
    /// @param token0 Address of token0 of the position (use address(0) for native ETH)
    /// @param token1 Address of token1 of the position
    /// @param recipient Address to receive the claimed fees
    function claimUniV4PositionFees(uint256 positionId, address token0, address token1, address recipient) external {
        if (lockOwners[positionId] != msg.sender) revert NotPositionOwner();

        // collecting fees is done by decreasing liquidity by 0
        bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR));

        // parameters for each of the actions
        bytes[] memory params = new bytes[](2);

        // Parameters for DECREASE_LIQUIDITY action, (decrease liquidity by 0).
        params[0] = abi.encode(positionId, 0, 0, 0, "");

        // Parameters for TAKE_PAIR action. Tokens and the receiver of the fees
        Currency currency0 = Currency.wrap(token0); // set address(0) for native ETH
        Currency currency1 = Currency.wrap(token1);
        params[1] = abi.encode(currency0, currency1, recipient);

        // There is no real modification of the liquidity position, this only collects fees
        IPositionManager(UNISWAPV4_POSITION_MANAGER).modifyLiquidities(
            abi.encode(actions, params),
            block.timestamp // no deadline
        );

        emit PositionFeesClaimed(msg.sender, positionId, token0, token1, recipient);

        // at the end of the transaction, verify that the position is still locked in this contract
        // The purpose of this is to make it clearer that this function cannot withdraw the position NFT
        if (UNISWAPV4_NFT.ownerOf(positionId) != address(this)) revert CannotWithdrawPositionNft();
    }
}
