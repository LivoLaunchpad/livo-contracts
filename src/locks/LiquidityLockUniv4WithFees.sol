// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {IERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
import {Ownable} from "lib/openzeppelin-contracts/contracts/access/Ownable.sol";
import {Clones} from "lib/openzeppelin-contracts/contracts/proxy/Clones.sol";
import {LivoToken} from "src/LivoToken.sol";
import {ILivoBondingCurve} from "src/interfaces/ILivoBondingCurve.sol";
import {ILivoGraduator} from "src/interfaces/ILivoGraduator.sol";
import {TokenConfig, TokenState, TokenDataLib} from "src/types/tokenData.sol";

import {IERC721} from "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol";

import {ILivoGraduator} from "src/interfaces/ILivoGraduator.sol";
import {ILivoToken} from "src/interfaces/ILivoToken.sol";
import {ILivoLaunchpad} from "src/interfaces/ILivoLaunchpad.sol";
import {SafeERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
import {PoolKey} from "lib/v4-core/src/types/PoolKey.sol";
import {IPoolManager} from "lib/v4-core/src/interfaces/IPoolManager.sol";
import {Currency} from "lib/v4-core/src/types/Currency.sol";
import {IHooks} from "lib/v4-core/src/interfaces/IHooks.sol";
import {Actions} from "lib/v4-periphery/src/libraries/Actions.sol";
import {IPositionManager} from "lib/v4-periphery/src/interfaces/IPositionManager.sol";
import {IAllowanceTransfer} from "lib/v4-periphery/lib/permit2/src/interfaces/IAllowanceTransfer.sol";
import {IPermit2} from "lib/v4-periphery/lib/permit2/src/interfaces/IPermit2.sol";
import {LiquidityAmounts} from "lib/v4-periphery/src/libraries/LiquidityAmounts.sol";
import {TickMath} from "lib/v4-core/src/libraries/TickMath.sol";
import {PositionConfig, PositionConfigLibrary} from "lib/v4-periphery/src/libraries/PositionConfig.sol";
import {PoolId, PoolIdLibrary} from "lib/v4-core/src/types/PoolId.sol";
import {FullMath} from "@uniswap/v4-core/src/libraries/FullMath.sol";
import {FixedPoint128} from "@uniswap/v4-core/src/libraries/FixedPoint128.sol";
import {SafeCast} from "@uniswap/v4-core/src/libraries/SafeCast.sol";
import {StateLibrary} from "lib/v4-core/src/libraries/StateLibrary.sol";

/// @title LiquidityLockUniv4WithFees
/// @notice A contract for locking Uniswap V4 NFTs representing liquidity positions, while at the same time allowing to claim fees generated by the position.
contract LiquidityLockUniv4WithFees {
    IERC721 public immutable uniswapV4Nft;

    IPositionManager public immutable uniswapPositionManager;

    constructor(address _uniswapV4Nft, address _uniswapPositionManager) {
        uniswapV4Nft = IERC721(_uniswapV4Nft);
        uniswapPositionManager = IPositionManager(_uniswapPositionManager);
    }

    error PositionIsAlreadyLocked();
    error NotPositionOwner();
    error CannotWithdrawPositionNft();

    event PositionLocked(address indexed owner, uint256 indexed positionId);
    event PositionFeesClaimed(
        address indexed owner, uint256 indexed positionId, address token0, address token1, address recipient
    );

    mapping(uint256 positionId => address owner) public lockOwners;

    function lockUniV4Position(uint256 positionId) external {
        if (lockOwners[positionId] != address(0)) revert PositionIsAlreadyLocked();

        lockOwners[positionId] = msg.sender;

        emit PositionLocked(msg.sender, positionId);

        IERC721(uniswapV4Nft).transferFrom(msg.sender, address(this), positionId);
    }

    function claimUniV4PositionFees(uint256 positionId, address token0, address token1, address recipient) external {
        if (lockOwners[positionId] != msg.sender) revert NotPositionOwner();

        // collecting fees is done by decreasing liquidity by 0
        bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR));

        // parameters for each of the actions
        bytes[] memory params = new bytes[](2);

        // Parameters for DECREASE_LIQUIDITY action, (decrease liquidity by 0).
        params[0] = abi.encode(positionId, 0, 0, 0, "");

        // Parameters for TAKE_PAIR action. Tokens and the receiver of the fees
        Currency currency0 = Currency.wrap(token0); // set address(0) for native ETH
        Currency currency1 = Currency.wrap(token1);
        params[1] = abi.encode(currency0, currency1, recipient);

        // There is no real modification of the liquidity position, this only collects fees
        IPositionManager(uniswapPositionManager).modifyLiquidities(
            abi.encode(actions, params),
            block.timestamp // no deadline
        );

        emit PositionFeesClaimed(msg.sender, positionId, token0, token1, recipient);

        // at the end of the transaction, verify that the position is still locked in this contract
        // The purpose of this is to make it clearer that this function cannot withdraw the position NFT
        if (uniswapV4Nft.ownerOf(positionId) != address(this)) revert CannotWithdrawPositionNft();
    }
}
