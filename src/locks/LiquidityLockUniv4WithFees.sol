// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {IERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
import {Ownable} from "lib/openzeppelin-contracts/contracts/access/Ownable.sol";
import {Clones} from "lib/openzeppelin-contracts/contracts/proxy/Clones.sol";
import {LivoToken} from "src/LivoToken.sol";
import {ILivoBondingCurve} from "src/interfaces/ILivoBondingCurve.sol";
import {ILivoGraduator} from "src/interfaces/ILivoGraduator.sol";
import {TokenConfig, TokenState, TokenDataLib} from "src/types/tokenData.sol";

import {IERC721} from "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol";

import {ILivoGraduator} from "src/interfaces/ILivoGraduator.sol";
import {ILivoToken} from "src/interfaces/ILivoToken.sol";
import {ILivoLaunchpad} from "src/interfaces/ILivoLaunchpad.sol";
import {SafeERC20} from "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
import {PoolKey} from "lib/v4-core/src/types/PoolKey.sol";
import {IPoolManager} from "lib/v4-core/src/interfaces/IPoolManager.sol";
import {Currency} from "lib/v4-core/src/types/Currency.sol";
import {IHooks} from "lib/v4-core/src/interfaces/IHooks.sol";
import {Actions} from "lib/v4-periphery/src/libraries/Actions.sol";
import {IPositionManager} from "lib/v4-periphery/src/interfaces/IPositionManager.sol";
import {IAllowanceTransfer} from "lib/v4-periphery/lib/permit2/src/interfaces/IAllowanceTransfer.sol";
import {IPermit2} from "lib/v4-periphery/lib/permit2/src/interfaces/IPermit2.sol";
import {LiquidityAmounts} from "lib/v4-periphery/src/libraries/LiquidityAmounts.sol";
import {TickMath} from "lib/v4-core/src/libraries/TickMath.sol";
import {PositionConfig, PositionConfigLibrary} from "lib/v4-periphery/src/libraries/PositionConfig.sol";
import {PoolId, PoolIdLibrary} from "lib/v4-core/src/types/PoolId.sol";
import {FullMath} from "@uniswap/v4-core/src/libraries/FullMath.sol";
import {FixedPoint128} from "@uniswap/v4-core/src/libraries/FixedPoint128.sol";
import {SafeCast} from "@uniswap/v4-core/src/libraries/SafeCast.sol";
import {StateLibrary} from "lib/v4-core/src/libraries/StateLibrary.sol";

/// @title LiquidityLockUniv4WithFees
/// @notice A contract for locking Uniswap V4 NFTs representing liquidity positions, while at the same time allowing to claim fees generated by the position.
contract LiquidityLockUniv4WithFees {
    /// @notice Uniswap V4 NFT positions contract
    IERC721 public immutable UNISWAPV4_NFT;

    /// @notice Uniswap V4 position manager contract
    IPositionManager public immutable UNISWAPV4_POSITION_MANAGER;

    /// @notice Mapping of position IDs to their lock owners
    mapping(uint256 positionId => address owner) public lockOwners;

    ///////////////////// Errors /////////////////////

    error PositionIsAlreadyLocked();
    error NotPositionOwner();
    error CannotWithdrawPositionNft();

    ///////////////////// Events /////////////////////

    /// @notice Emitted when a position is locked
    event PositionLocked(address indexed owner, uint256 indexed positionId);
    /// @notice Emitted when fees are claimed from a locked position
    event PositionFeesClaimed(
        address indexed owner, uint256 indexed positionId, address token0, address token1, address recipient
    );

    //////////////////////////////////////////////////

    /// @notice Initializes the liquidity lock contract
    /// @param _uniswapV4Nft Address of the Uniswap V4 NFT positions contract
    /// @param _uniswapPositionManager Address of the Uniswap V4 position manager
    constructor(address _uniswapV4Nft, address _uniswapPositionManager) {
        UNISWAPV4_NFT = IERC721(_uniswapV4Nft);
        UNISWAPV4_POSITION_MANAGER = IPositionManager(_uniswapPositionManager);
    }

    //////////////////  EXTERNALS ////////////////////

    /// @notice Locks a Uniswap V4 position NFT in this contract
    /// @param positionId The ID of the position to lock
    // todo update with new argument positionOwner
    function lockUniV4Position(uint256 positionId) external {
        // todo pass receiver/positionOwner
        if (lockOwners[positionId] != address(0)) revert PositionIsAlreadyLocked();

        lockOwners[positionId] = msg.sender;

        emit PositionLocked(msg.sender, positionId);

        IERC721(UNISWAPV4_NFT).transferFrom(msg.sender, address(this), positionId);
    }

    /// @notice Claims fees from a locked Uniswap V4 position
    /// @param positionId The ID of the position to claim fees from
    /// @param token0 Address of token0 of the position (use address(0) for native ETH)
    /// @param token1 Address of token1 of the position
    /// @param recipient Address to receive the claimed fees
    function claimUniV4PositionFees(uint256 positionId, address token0, address token1, address recipient) external {
        if (lockOwners[positionId] != msg.sender) revert NotPositionOwner();

        // collecting fees is done by decreasing liquidity by 0
        bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR));

        // parameters for each of the actions
        bytes[] memory params = new bytes[](2);

        // Parameters for DECREASE_LIQUIDITY action, (decrease liquidity by 0).
        params[0] = abi.encode(positionId, 0, 0, 0, "");

        // Parameters for TAKE_PAIR action. Tokens and the receiver of the fees
        Currency currency0 = Currency.wrap(token0); // set address(0) for native ETH
        Currency currency1 = Currency.wrap(token1);
        params[1] = abi.encode(currency0, currency1, recipient);

        // There is no real modification of the liquidity position, this only collects fees
        IPositionManager(UNISWAPV4_POSITION_MANAGER).modifyLiquidities(
            abi.encode(actions, params),
            block.timestamp // no deadline
        );

        emit PositionFeesClaimed(msg.sender, positionId, token0, token1, recipient);

        // at the end of the transaction, verify that the position is still locked in this contract
        // The purpose of this is to make it clearer that this function cannot withdraw the position NFT
        if (UNISWAPV4_NFT.ownerOf(positionId) != address(this)) revert CannotWithdrawPositionNft();
    }
}
